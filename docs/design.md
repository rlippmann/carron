# Carron Design Notes (v0.1)

This document captures the engineering decisions and invariants for Carron v0.1. It is intended for contributors. User-facing documentation lives in `README.md`.

---

## Scope and Non-Goals (v0.1)

Carron v0.1 is intentionally narrow:

- No repository scanning or candidate discovery
- No “list targets” functionality
- No deep static analysis beyond what is required to resolve an explicit target
- No pytest plugin integration (only subprocess invocation in `--mode run`)
- No provider-specific LLM APIs (OpenAI-compatible only)

Targets must be explicit:

- `module:func`
- `module:Class.method`
- `file.py:func`
- `file.py:Class.method`

---

## Commands and Defaults

Primary workflow:

- `carron test <target>`: uses the planner to select an appropriate forge, then generates tests.

Advanced workflow (explicit forge selection):

- `carron prop <target>`
- `carron diff <targetA> <targetB>`

Modes:

- `--mode emit` (default): generate tests only
- `--mode check`: validate generated tests (no pytest execution)
- `--mode run`: execute tests via pytest subprocess

Default behavior:

- `carron test <target>` defaults to `--mode emit` (never runs tests implicitly).

---

## Package Layout (v0.1)

This layout is not a public API and may change during early development.

carron/
├─ pyproject.toml
├─ README.md
├─ LICENSE
├─ docs/
│  ├─ design.md
│  └─ planner.md
├─ src/
│  └─ carron/
│     ├─ __init__.py
│     ├─ cli.py
│     ├─ main.py
│
│     ├─ core/
│     │  ├─ types.py
│     │  └─ schema.py
│
│     ├─ interfaces/
│     │  ├─ forge.py
│     │  ├─ llm.py
│     │  └─ adapter.py
│
│     ├─ planner/
│     │  └─ heuristic.py
│
│     ├─ forges/
│     │  ├─ prop/
│     │  │  ├─ forge.py
│     │  │  └─ prompts.py
│     │  └─ diff/
│     │     ├─ forge.py
│     │     ├─ prompts.py
│     │     └─ schema.py
│
│     ├─ adapters/
│     │  └─ python/
│     │     └─ adapter.py
│
│     ├─ llm/
│     │  └─ openai_compat/
│     │     └─ client.py
│
│     └─ runner/
│        └─ pytest_runner.py
│
└─ tests/
   └─ test_smoke.py

---

## Output Directory and File Ownership

Default output directory:

- `tests/generated/`

Rules:

- Carron only writes inside the configured output directory.
- Carron never modifies files outside the output directory.
- Carron may overwrite files it previously generated inside the output directory.
- Carron should avoid deleting unrelated files; if cleanup is needed, it should be limited to known Carron-owned paths.

Generated files must include an ownership header comment, e.g.:

- “Generated by Carron. Do not edit by hand.”
- Include the command used (optional but recommended)
- Include Carron version (optional)

---

## Architecture Boundaries

Carron is a pipeline:

```

CLI → Forge → Artifacts → (optional) Runner
↘ Adapter
↘ LLM

```

Key invariants:

- Forges are pure generators: `ForgeRequest → ForgeResult`
- Forges **do not**:
  - parse CLI arguments
  - read configuration files
  - read environment variables
  - write to the filesystem
  - run subprocesses
  - perform raw HTTP calls

Environment interaction is owned by the CLI layer:

- Config loading
- Filesystem writes
- Pytest execution
- Logging/console output formatting

---

## Interfaces

Carron defines three core interfaces:

1) **Forge**
- Input: `ForgeRequest`
- Output: `ForgeResult`
- Produces artifacts + diagnostics only

2) **LLMClient**
- OpenAI-compatible chat completions interface
- Minimal method: `generate(messages, model, options) -> str`

3) **LanguageAdapter**
- Parses and resolves explicit targets
- Provides naming conventions for output files
- Supplies minimal metadata (best-effort): kind, signature, doc first line

---

## Data Flow Contract

### Forge Request

```
forge: "prop"
mode: "emit" | "check" | "run"
target: "mypkg.math:clamp"
context: GenerationContext
limits: {...}
feedback: optional
```

`GenerationContext` provides the capabilities a forge needs without exposing subsystem implementations.
Forges must not depend on adapters, LLM clients, configuration, or environment directly.

The context may provide functions such as:

- generate_text(messages) -> str
- get_target_summary(target) -> TargetSummary

This keeps forges pure and prevents dependency cycles.

---

### Forge Result

```
status: ok | failed | partial
artifacts: [{path, content}]
diagnostics: [{level, message}]
```

The CLI writes files and optionally runs pytest.

---

## LLM Interaction Rules (Determinism)

Carron should treat the LLM as an unreliable text generator and enforce discipline locally.

Rules:

- Whenever structured output is needed, Carron requests strict JSON.
- Carron performs:
  1. JSON parse
  2. schema validation (or equivalent structural checks)
- On failure, Carron retries up to `N` times (default `2`) with a corrective instruction:
  - “Return ONLY valid JSON matching the schema. No markdown.”

Failure behavior:

- If retries are exhausted, Carron should produce no new files and return a non-zero exit code.

---

## Planner (`carron suggest` / `carron test`)

`carron test` uses an internal planner to select among implemented forges (v0.1: `prop`, `diff`).

- `carron suggest <target>` prints the planner recommendation.
- `carron suggest <target> --apply ...` applies the recommendation.

Planner constraints:

- No repository scanning.
- Only uses explicit target + adapter summary.
- Output must be strict JSON with a small validated schema.
- Planner is advisory; Carron must validate the recommendation against the set of implemented forges.

(Planner schema and prompt live in `docs/planner.md`.)

---

## Dependency Policy

Carron core runtime dependencies should remain minimal.

Guidelines:

- Prefer small, standard libraries.
- Hypothesis is not required to run Carron; it is required to *execute generated `prop` tests*.
- Pytest is not required to *emit* tests; it is required for `--mode run`.

Recommended packaging approach:

- Base install has only Carron runtime deps.
- Optional extras may include:
  - `prop` extra: `hypothesis`
  - `dev` extra: `pytest`, linters, type-checkers

---

## Runner Policy (`--mode run`)

`--mode run` executes tests via subprocess (pytest). It must be isolated from forge logic.

Rules:

- Runner is invoked only by the CLI layer.
- Runner output (stdout/stderr + failure summaries) may be passed back to the forge as `feedback` for regeneration.
- Any repair loop must be bounded (default max iterations: `2`).

---

## Exit Codes

Suggested exit codes:

- `0`: success
- `1`: configuration / generation failure (invalid target, LLM failure, schema failure)
- `2`: check/validation failure (e.g., generated file fails import/syntax check if implemented)
- `3`: test execution failures (pytest returns non-zero)

Exact exit code mapping may be refined during early implementation.

---

## Interface Versioning

Request/result structures should include a version field:

- `version: 1`

This allows future evolution without ambiguous behavior.

---

## Testing Carron (Dogfooding)

Carron should be able to generate tests for itself by targeting deterministic, pure functions first:

- target parsing
- output path naming
- schema validation helpers
- config precedence logic (if implemented as pure functions)

Avoid early dogfooding on:

- network I/O (LLM client)
- subprocess runner
- filesystem mutation logic

